
// TODO: this gets less painful if i implement thread locals the normal way 
//       (which i'll probably want to do for rust anyway)
Globals :: @struct {
    stack: AlignedStack;
};
globals :: @static(Globals);






host_os :: {
    // when compiled by build.rs, it always passes -arch,-os. 
    // this is the host franca-sys will run on (not the host build.rs is running on)
    i := cli_args().index_of(fn(it) => it[] == "-os").expect("-os");
    os := cli_args().index(i + 1)[];
    os := Os.from_name(os.str());
    os.unwrap()
};

fn init_globals() *Globals #export = {
    @if(globals.stack.usable.len > 0) return(globals);
    // TODO: this won't work on linux if not linking libc
    stack := import("@/lib/sys/threads.fr")'allocate_stack(true, host_os);
    thread := bit_cast_unchecked(*u8, *Thread, stack.usable.ptr);
    thread.stack = stack;
    thread.first_environment.current_os = (@as(i64) host_os.raw()).trunc();
    thread.stack_reserved_size = 1.shift_left(16);

    globals.stack = stack;
    
    call_in_stack(*Thread, void, thread, fn(thread) => {
        c := thread.first_environment&;
        thread.first_temporary_allocator = init(page_allocator, 1.shift_left(20));
        c.temporary_allocator = thread.first_temporary_allocator&;
        c.temporary_allocator_i = c.temporary_allocator.borrow();
        c.general_allocator = libc_allocator;
        c.panic_hook = print_and_exit1;  // TODO: get stacktraces back up into the rust code
        c.thread_index = 1;
    });
    
    // :LEAK
    globals
};

CompileCmd :: @struct {
    frc: []u8;
    out: []u8;
    name: Str;
    p: rawptr;
    m: *Qbe.Module;
    jit: u8;
};

fn compile_one(_: *Globals, arg: *CompileCmd) void #export = {
    call_in_stack(*CompileCmd, void, arg, fn(arg) => {
        m := general_allocator().box_zeroed(Qbe.Module);
        // TODO: pass this in so can cross compile
        Qbe'backend'init_module(m, (
            type = @if(arg.jit == 0, .Relocatable, .JitOnly), 
            os = query_current_os(),  
            arch = query_current_arch(), 
        ));
        
        H :: *Qbe.Incremental.Header;
        ::Result(H, Str);
        header: H = or check(arg.frc) { e |
            @panic("invalid frc file: %", e)
        };
        Qbe'backend'load_all(header, m);
        m.Qbe'backend'compile_suspended();
        
        if m.goal.type != .JitOnly {
            chunks := {m.target.finish_module}(m);
            arg.out = concat(chunks, general_allocator());
            drop(m);
        } else {
            @if(is_linking_libc()) m.Qbe'fill_from_libc();
            m.make_exec();
            p := m.get_addr(arg.name) 
                || @panic("couldn't find %", arg.name);
            arg.p = p;
            arg.m = m;
        };
    });
}

fn drop_module(_: *Globals, arg: *CompileCmd) void #export = {
    call_in_stack(*CompileCmd, void, arg, fn(arg) => {
        ::ptr_utils(@type arg.m[]);
        if !arg.m.is_null() {
            arg.m.drop();
        };
        general_allocator().dealloc(u8, arg.out);
        general_allocator().dealloc_one(Qbe.Module, arg.m);
        arg.m = zeroed(*Qbe.Module);
        arg.out = "";
        arg.p = zeroed(rawptr);
    });
}

call_in_stack :: fn($A: Type, $R: Type, in: A, $f: @Fn(a: A) R) R #generic = {
    cis :: import("@/tests/fr/multiple_stacks.fr").call_in_stack;
    s := globals.stack.usable;
    out := @ref zeroed(R);
    arg := (in, out);
    T :: @type arg;
    cis(bit_cast_unchecked(*u8, *i64, s.end_pointer()), callee, T.raw_from_ptr(arg&));
    callee :: fn(arg: rawptr) void = {
        in, out := T.ptr_from_raw(arg)[];
        out[] = f(in);
    };
    out[]
}

// macos linker doesn't like weak symbols by default idk how to ask cargo to ask for them. 
//       doesn't work: println!("cargo::rustc-link-arg=-Wl,-undefined,dynamic_lookup");
::@if(@run(host_os == .macos)) {  // HACK
fn __errno_location() void #export = todo();
fn FR_openat() void #export = todo();
fn @"fstatat$INODE64"() void #export = todo();
fn FR_wasm_jit_event() void #export = todo();
fn jit_instantiate_module() void #export = todo();
fn ppoll() void #export = todo();
};

#use("@/lib/sys/threads.fr");
Qbe :: import("@/backend/lib.fr").Qbe;    
